"""Pandapipes network builder from GraphML heating network.

Sources are heat sources (mass-flow sources), buildings are sinks, edges are pipes.
GraphML is expected to be generated by GraphGenerator with:
- node attributes: node_type in {street, street_connection, building, heat_source}, x, y
- optional building attribute: heat_demand (annual, unit per config)
- optional heat source attributes: annual_heat_production (annual), heat_source_id, heat_source_type
- edge attributes: edge_type in {street_segment, building_connection, heat_source_connection}, length (meters)

Two-pipe semantics: we model a single hydraulic graph using Î”T for mass balance.
"""

from __future__ import annotations

from typing import Any, Dict, Tuple, List
from pathlib import Path
import logging
import json
import math

import networkx as nx  # type: ignore
import numpy as np  # type: ignore

try:
    import pandapipes as pp  # type: ignore
except Exception:  # pragma: no cover - environment without pandapipes
    pp = None  # type: ignore

from config import Config


logger = logging.getLogger(__name__)


class PandapipesBuilder:
    """Builds a pandapipes network from the project's GraphML."""

    def __init__(self, config: Config):
        self.config = config
        self.pp_cfg = config.pandapipes
        self.paths = config.data_paths

    # ------------- Public API -------------
    def build_from_graphml(self, graphml_path: str | None = None) -> Dict[str, Any]:
        """Convert GraphML into a pandapipes net and write outputs.

        Returns a dict summary with counts and file paths.
        """
        if pp is None:
            raise RuntimeError("pandapipes is not installed or failed to import")

        graphml = graphml_path or self.paths.get("network_graphml_path", "./data/heating_network.graphml")
        if not Path(graphml).exists():
            raise FileNotFoundError(f"GraphML not found at {graphml}")

        logger.info(f"Reading GraphML from {graphml}")
        G: nx.Graph = nx.read_graphml(graphml)

        net = pp.create_empty_network(fluid=self.pp_cfg.get("fluid", "water"))

        # Temperatures
        t_supply_c = float(self.pp_cfg.get("supply_temperature_C", 80.0))
        t_return_c = float(self.pp_cfg.get("return_temperature_C", 50.0))
        delta_T = float(self.pp_cfg.get("delta_T_K", max(1.0, t_supply_c - t_return_c)))
        cp = float(self.pp_cfg.get("cp_J_per_kgK", 4180.0))
        rho = float(self.pp_cfg.get("rho_kg_per_m3", 985.0))

        # Junction defaults
        p_min_bar = float(self.pp_cfg.get("min_junction_pressure_bar", 1.5))
        t_k = (t_supply_c + 273.15)

        # Map GraphML nodes to pandapipes junction indices
        node_to_junc: Dict[Any, int] = {}

        # Pandapipes requires geodata to be in meters; GraphGenerator uses EPSG:5243 in meters
        # We'll store x/y in net.junction_geodata for plotting/debug

        # Create junctions for every node
        for n, data in G.nodes(data=True):
            try:
                x = float(data.get("x"))
                y = float(data.get("y"))
            except (TypeError, ValueError):
                # Skip nodes without coordinates
                logger.debug(f"Skipping node {n} without valid coords")
                continue

            j_idx = pp.create_junction(
                net,
                pn_bar=p_min_bar,
                tfluid_k=t_k,
                name=f"n_{n}_{data.get('node_type','')}"
            )
            node_to_junc[n] = j_idx
            # Store geodata (compat: set directly on DataFrame if helper not available)
            try:
                # Some pandapipes versions lack a convenience function; set DataFrame directly
                net.junction_geodata.loc[j_idx, ["x", "y"]] = [x, y]
            except Exception as ge:
                logger.debug(f"Could not set junction geodata for {j_idx}: {ge}")

        # Create pipes for allowed edge types
        allowed_edge_types = set(self.pp_cfg.get(
            "edge_types_as_pipes",
            ["street_segment", "building_connection", "heat_source_connection"],
        ))

        d_default = float(self.pp_cfg.get("default_pipe_diameter_m", 0.10))
        k_rough = float(self.pp_cfg.get("roughness_m", 1.0e-4))

        pipe_count = 0
        for u, v, edata in G.edges(data=True):
            e_type = edata.get("edge_type")
            if e_type not in allowed_edge_types:
                continue
            if u not in node_to_junc or v not in node_to_junc:
                continue

            length = float(edata.get("length", 0.0) or 0.0)
            if length <= 0.0:
                # Approximates Euclidean length from coordinates if missing
                try:
                    x1, y1 = float(G.nodes[u]["x"]), float(G.nodes[u]["y"])
                    x2, y2 = float(G.nodes[v]["x"]), float(G.nodes[v]["y"])
                    length = float(np.hypot(x2 - x1, y2 - y1))
                except Exception:
                    length = 1.0

            pp.create_pipe_from_parameters(
                net,
                from_junction=node_to_junc[u],
                to_junction=node_to_junc[v],
                length_km=length / 1000.0,
                diameter_m=d_default,
                k_mm=k_rough * 1000.0,  # convert m -> mm
                name=f"{e_type}_{u}_{v}",
            )
            pipe_count += 1

        # Compute total sink demand (kg/s) from buildings
        op_hours = float(self.pp_cfg.get("assume_continuous_operation_h_per_year", 2000))
        unit_building = self.pp_cfg.get("building_heat_demand_unit", "kWh_per_year")

        def annual_to_kw(val_kwh_per_year: float) -> float:
            if op_hours <= 0:
                return 0.0
            return float(val_kwh_per_year) / op_hours

        sinks: List[int] = []
        total_sink_mdot = 0.0
        for n, data in G.nodes(data=True):
            if data.get("node_type") != "building":
                continue
            if n not in node_to_junc:
                continue
            hd_annual = data.get("heat_demand", 0.0) or 0.0
            try:
                hd_annual = float(hd_annual)
            except (TypeError, ValueError):
                hd_annual = 0.0

            # Convert annual energy to design power (kW) using operation hours
            p_kw = annual_to_kw(hd_annual)
            p_w = p_kw * 1000.0
            mdot = (p_w / (cp * max(1e-6, delta_T)))  # kg/s

            if mdot > 0:
                s_idx = pp.create_sink(net, junction=node_to_junc[n], mdot_kg_per_s=mdot, name=f"sink_{n}")
                sinks.append(s_idx)
                total_sink_mdot += mdot

        # Create sources at heat_source nodes, split by capacity share
        unit_source = self.pp_cfg.get("heat_source_capacity_unit", "kWh_per_year")
        split_mode = self.pp_cfg.get("multi_source_split", "by_capacity")

        sources: List[int] = []
        # Gather capacities
        hs_list: List[Tuple[Any, float]] = []  # (node_id, mdot_kg_per_s_capacity)
        total_hs_capacity_mdot = 0.0
        for n, data in G.nodes(data=True):
            if data.get("node_type") != "heat_source":
                continue
            if n not in node_to_junc:
                continue
            cap_annual = data.get("annual_heat_production", 0.0) or 0.0
            try:
                cap_annual = float(cap_annual)
            except (TypeError, ValueError):
                cap_annual = 0.0
            p_kw = annual_to_kw(cap_annual)
            mdot_cap = (p_kw * 1000.0) / (cp * max(1e-6, delta_T))
            hs_list.append((n, mdot_cap))
            total_hs_capacity_mdot += mdot_cap

        if total_sink_mdot > 0 and hs_list:
            if split_mode == "equal" or total_hs_capacity_mdot <= 0:
                share = total_sink_mdot / len(hs_list)
                for n, _ in hs_list:
                    src = pp.create_source(net, junction=node_to_junc[n], mdot_kg_per_s=share, name=f"source_{n}")
                    sources.append(src)
            else:
                # Proportional to capacity
                for n, mdot_cap in hs_list:
                    frac = (mdot_cap / total_hs_capacity_mdot) if total_hs_capacity_mdot > 0 else 0.0
                    mdot_src = frac * total_sink_mdot
                    src = pp.create_source(net, junction=node_to_junc[n], mdot_kg_per_s=mdot_src, name=f"source_{n}")
                    sources.append(src)

        # Optional: write to JSON
        out_paths = self.pp_cfg.get("output_paths", {})
        json_path = out_paths.get("pandapipes_net_json_path", "./data/pandapipes/network.json")
        dump_dir = out_paths.get("pandapipes_dump_dir", "./data/pandapipes/")
        Path(dump_dir).mkdir(parents=True, exist_ok=True)
        Path(json_path).parent.mkdir(parents=True, exist_ok=True)

        try:
            # Prefer native pandapipes JSON export
            pp.to_json(net, json_path)
        except Exception as e:
            logger.error(f"Failed to export pandapipes net to JSON: {e}")
            raise

        summary = {
            "junctions": int(len(node_to_junc)),
            "pipes": int(pipe_count),
            "sinks": int(len(sinks)),
            "sources": int(len(sources)),
            "total_sink_mdot_kg_per_s": float(total_sink_mdot),
            "graphml": graphml,
            "json_path": json_path,
        }
        logger.info(f"Pandapipes network built: {summary}")
        return summary


def build_default() -> Dict[str, Any]:
    """Convenience runner using default config and paths."""
    cfg = Config()
    builder = PandapipesBuilder(cfg)
    return builder.build_from_graphml()
